#--<label>
#<As A> (one line)
#<In Order To> (one line)
#<I Want To> (any number of lines
#
# For each additional piece of data, ==<key> followed by the key data
#==<key>
#<keydata>
#
# End with
#--
#
# CATEGORIES
# general - The most abstract/conceptual features of contracts
# metadata - needs for specifying information ABOUT a contract condition
# control - needs related to controlling contract behavior
# location - needs related to where contract conditions can go
# syntax - needs related to general contract syntax
# contents - needs related to what can go into a contract condition
# violations - requirements for what happens on general contract violation

--dev.reason.knowl
Developer
Reason explicitly
Annotate my program anywhere in the code with my current understanding of its
structure or execution
==categories
general location
==x2032.N4842
25
==x2032.N4820
90
==x2032.P1429
90
==x2032.P1607
90
==x2032.details
Without a specific contract checking facility there are still ways to annotate
a program with information about program contracts, but those are limited to
either comments (with no validation or normative effect), the classic C `assert`
macro, or larger nonstandard macro-based facilities
(with no consistency in representation across different implementations).
Typical usage would be within a function writing something like this:

```
void sqrt(double n) {
  assert(n >= 0.0);
  BSLS_ASSERT(n >= 0.0);
}
```

All of the contract proposals that were considered introduced the same syntax
for expressing an expectation that a certain boolean predicate was true at
specified points in a program.  These satisfy most common use cases in the wild
for contract predicates, although being only boolean predicates makes them
fall short of being able to capture many more involved or not runtime checkable
aspects of a function contract.  These include the ability to express this
within a function body as assertions like this:

```
double  sqrt(double n) {
  [[ assert : n >= 0.0 ]]
  // ..
}
```

More notably, annotations of expectations about execution could be added on
function declarations as well -- something not possible with a solely language based
solution -- like this:

```
void sqrt(double n) [[ pre : n >= 0.0 ]];
```
==description
This general use case expresses the desire to place information about
a program's expected execution state in many different places throughout
the program - possibly including "upon function entry", "whenever this
line of code is executed", "at all times when a class of this type is not
actively executing a member function", or others.
--

--dev.reason.confidence
Developer
Reason explicitly
Express a spectrum of confidence in my annotations, from "unsure" and asking
for validation, to "sure" and asking for some effect to be applied (eg.
"maybe", "definitely", "assume" 'something')
==categories
general metadata
==x2032.N4842
40
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
50
==x2032.details
While BDE's bsls_assert does not provide confidence as something that can be
used to control contract behavior, it is not hard to envision that such a thing
could be built into a macro-based solution.

Build-level-only solutions do not capture this at all (where N4820 and P1429
presented `default`, `audit`, and `axiom` as the only extra annotations that
could be put on a contract, and those were intended to capture cost of checking
not confidence).

P1607's literal semantics do not provide this directly, but here again one
could envision combining a macro-based solution to choose literal semantics
that would capture confidence or importance and compute behavior based on that.
==description
This high level use case expresses the need to attach information to contract
conditions that is beyond the statement of the condition itself, and instead
has user-provided metadata about both the confidence in the condition and the
desired behavior of the program in relation to that condition.
--

--dev.reason.importance
Developer
Reason explicitly
Express a spectrum of importance of my annotations, from "critical" (eg. bring
the system down) to "minor" (eg. lead to a slower fallback)
==categories
general metadata
==x2032.N4842
40
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
50
==x2032.see
dev.reason.confidence
==description
This high level use case expresses the desire to have metadata on contract
conditions associated with what downsides violations might have, perhaps
indicating that while a certain condition is expected to be met, the library
does guarantee that the downsides will not be catastrophic.
--

--dev.reason.cost
Developer
Reason explicitly
Express a spectrum of expected cost at compile or runtime of my annotations,
from "unrunnable" to "expensive" to "cheap"
==categories
general metadata
==x2032.N4842
40
==x2032.N4820
80
==x2032.P1429
80
==x2032.P1607
50
==x2032.details
A macro-based solution would again be able to be built to use an expression
of the cost of checking to determine how a contract will be treated, and BDE
does exactly this with the following variations on how a contract can be
checked:

```c++
void foo(int x) {
  BSLS_ASSERT_OPT(x != 0);
  BSLS_ASSERT(x < Utils::getMaxXValue());
  BSLS_ASSERT_SAFE(factorial(x) < Utils::getMaxXFactorial());
}
```

The `default`, `audit`, and `axiom` levels captured this similarly:

```c++
void foo(int x) {
  [[ assert default : x != 0 ]];
  [[ assert audit : x < Utils::getMaxValue() ]];
  [[ assert axiom : is_reachable( staticranges[x].begin(),
                                  staticranges[x].end() ) ]];
}
```

Similar to the case for confidence and importance, any system that was built
on top of literal semantics for P1607 with macros would be able to choose to
capture cost as part of that control of contract behavior.
==description
This use case expresses the desire to have metadata about contract conditions
that capture at least 3 (if not more) granularities of "cost" to be used as
input in some way to other decisions about what the contracts might do or how
they might be interpreted.
--

--dev.reason.behavior
Developer
Reason about executions
Have annotations affect the execution of my program in accordance with my
expectations
==categories
general behavior
==x2032.N4842
25
==x2032.N4820
75
==x2032.P1429
90
==x2032.P1607
90
==x2032.details
N4820 contracts allowed for contract checks to either introduce undefined
behavior or be checked at runtime.

P1429 and P1607 provide more flexibility by exposing the choice of 4 different
semantics for contracts, with the primary difference being the granularity of
that control.
==description
The desire to have behaviors (such as generating runtime checks or
optimizations) and the expected behavior explicitly defined by the standard in
order to help users reason about what a program will do/has done when a
contract is violated. Note that having this in the standard allows for
leveraging expectations of behavior across all compliant platforms.
--

--dev.reason.sideeffects
Developer
Reason about executions
Ensure annotations do not substantially change the meaning of my program
whether enabled or disabled
==categories
general behavior
==x2032.N4842
10
==x2032.N4820
5
==x2032.P1429
10
==x2032.P1607
10
==x2032.details
A macro-based solution has no clear way to enforce this kind of requirement,
other than the basic aspect that by making the macros disableable you can
attempt to test that behavior has not been impacted in distinct builds.

N4820 does not provide any clean way to disable contract checks (since any
unchecked contract introduces UB) so even that form of testing is not possible.

On top of that, all of the previous contract proposals made any side effect
undefined behavior - turning any such side effects into an uncontrolled and
dangerous thing to have in code, but not provide any real protection against it.
Of note, [P1670R0](http://wg21.link/P1670R0) was scheduled for Cologne which had one proposal for an
attempt to address this.
==description
This high-level use case expresses a desire that any execution effective
transformations an annotation might apply be "reasonable", ie. not surprising
or counter intuitive (such as time-travel optimizations).

There is a tension between allowing side effects in contract conditions and
disallowing them completely.  In general, writing code with absolutely no side
effects is very hard, and there are pitfalls if the language is actively
hostile to accidental side effects.  On the other hand, conditions with side
effects are also not elidable by the compiler, since the act of checking them
is observable.

* N4810 contracts made any side effect undefined behavior.
* P1670 suggested allowing side effects but also, when contracts are runtime
checked, allowing elision of the predicate (along with its side effect) if the
predicate result can be determined.
--

--dev.reason.behaviorcontrol
Developer
Reason about executions
Have the effect of annotations on executions be user controllable (ie. decide
whether "cheap" checks or "critical" terminates)
==categories
general control
==x2032.N4842
65
==x2032.N4820
50
==x2032.P1429
55
==x2032.P1607
70
==x2032.details
A macro-based solution can be built to use command line and in-code annotations
to determine contract behavior.  P1607 and a macro-only facility would both
be able to provide any form of behavior control that users might wish to build.

N4820 and P1429 contract control is much more limited, primarily being only
doable at the build level of granularity.
==description
This encompasses some specific need to control, either when writing code or
when building code, what behavior (if any) is associated with a contract
condition.
--

--dev.adapt
Developer
Adapt and progress with my project
Be able to easily change my confidence, importance, or other properties of my
annotations over time
==categories
control
==x2032.N4842
40
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
40
==x2032.details
The build-level supporting options (N4820 and P1429) allow changing the one
attribute they expose (cost).   The macro-based solutions would have to build
support for this, but can clearly put that in the source code and thus make
editing the attributes of an annotation easy to edit.
==description
--

--dev.readable.syntax
Developer
Have readable annotations
Have annotations with a succinct and elegant syntax
==categories
general syntax
==x2032.N4842
40
==x2032.N4820
80
==x2032.P1429
80
==x2032.P1607
70
==x2032.details
Obviously N4820 provides no explicit syntax and is limited to macros, but that
still allows for using readable C++ in the annotations.

P1607 likely requires macros to facilitate any global controls over behavior,
so is a slightly worse syntactic option than what N4820 and P1429 provide (which
have identical syntax).
==description
--

--dev.readable.keywords
Developer
Have readable annotations
Have annotation keywords or names with intuitive, clear, and unambiguous
meanings
==categories
syntax
==x2032.N4842
10
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
60
==x2032.details
Given that it provides no new keywords for contracts, readability is going to be
entirely dependent on what macro based facility is being used with N4842.

For N4820 and P1429, the clarity of 'default' is fairly opaque, and a huge
amount of reflector discussion and contention has revolved around the meaning and
use of axiom, so they fair poorly here.

P1607 removes the contentious keywords, but introduces new bespoke keywords
that while clear are not necessarily intuitive to all, along with needing to
build any other controls on top of those with macros, so it seems only slightly
better in this regard.
==description
Any keywords chosen for use within the feature should be easily distinguishable
(to avoid name churn such as expects/ensures to pre/post) and be very
clearly matched to what they will do within the language (unlike, for example,
axiom).
--

--dev.readable.priority
Developer
Have readable annotations
Have my contract specification to be visually primary, and secondary
information (syntax, hints, roles, levels, etc.) to not be distracting
==categories
syntax metadata
==x2032.N4842
15
==x2032.N4820
10
==x2032.P1429
10
==x2032.P1607
10
==x2032.details
All of the attribute-based solutions put the meta-information first before the
expression, counter to what this use case is asking for.  A macro-based solution
could choose to prioritize information differently, but would also be
restricted in how the information gets passed into the macro.
==description
This use case indicates a preference to have any metadata about a contract be
visually very minimal or come after the predicate itself.
--

--dev.parsable
Developer
Interoperate with tools or persons
A syntax that can both be parsed and can be reasoned about semantically
==categories
syntax
==x2032.N4842
40
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
70
==x2032.see
dev.readable.syntax
==description
--

--dev.tooling
Developer
Interoperate with tools or persons
Expose annotations to tools that might leverage them (eg. code linter, static
analyzer, semantic prover, compiler sanitizer, binary analyzer, code reviewer,
etc.)
==categories
syntax
==x2032.N4842
0
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
Entirely macro-based facilities would need to be ubiquitous enough for tooling
vendors to choose to support them explicitly, along with those tooling vendors
needing to work around the difficulties of managing pre-preprocessor based
analysis.
==description
--

--cppdev.syntax.familiar
C++ Developer
Get up to speed
Have annotations use familiar syntax
==categories
syntax
==x2032.N4842
50
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
dev.readable.syntax
==description
--

--cppdev.syntax.cpp
C++ Developer
Get up to speed
Have annotations use C++ syntax
==categories
syntax
==x2032.N4842
50
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
dev.readable.syntax
==description
--

--cppdev.syntax.reuse
C++ Developer
Reuse code
Have annotations use my custom types or functions
==categories
syntax contents
==x2032.N4842
75
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
dev.readable.syntax
==description
Rather than requiring special functions or types (or some completely new
thing), contract should be able to leverage any program logic related to their
statement that is already written/writable in C++.
--

--cppdev.location
C++ Developer
Have a single source of truth
Use same source file for both code and annotations
==categories
location
==x2032.N4842
100
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
100
==x2032.see
dev.readable.syntax
==description
This as a preference to needing to specify contracts in a completely separate
metadata file of some sort.
--

--cppdev.syntax.macros
C++ Developer
Support modern features
Minimize use of macros
==categories
general syntax
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
60
==x2032.P1607
25
==x2032.details
Obviously not very much can be done with the base language without macros.

P1607 would require macros to support any form of global controls, so it gets
the lowest rating for this use case, while P4820 would be usable for basic
applications without macros, and P1429 would be slightly more flexible without
needing to resort to macros.
==description
The desire is to not require use of macros in order to satisfy the majority
of use cases.
--

--cppdev.modules
C++ Developer
Support modern features
Be interoperable with modules
==categories
general
==x2032.N4842
10
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
25
==x2032.details
A purely macro based solution would have the worst interaction with modules.

The language-based solutions were expected to have basic support for modules,
since all would have landed in C++20, but no specific modules-related features
were initially planned.
==description
All contract control features and behaviors should be interoperable in a
reasonable way with any partially or fully modularized C++ program.
--

--cppdev.coroutines
C++ Developer
Support modern features
Be interoperable with coroutines
==categories
location
==x2032.N4842
25
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
25
==x2032.details
All of the solutions would work perfectly fine within the body of a coroutine.
Coroutine handling of contracts on inputs, outputs, and states when resuming
a coroutine had not had any discussions or support planned in the proposals
as they existed, so none of the proposals support coroutines any better than
a purely macro-based solution.
==description
Contracts on coroutines open up a number of new situations to consider because
there might be requirements on what the state of the program is whenever a
coroutine resumes execution, and there might be promises a coroutine makes
prior to each time it suspends.
--

--cppdev.concepts
C++ Developer
Support modern features
Be interoperable with concepts
==categories
location
==x2032.details
Nothing about the prior facilities seems to benefit or hinder the use of
concepts.
==x2032.N4842
25
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
25
==description
--

--cppdev.existing.std
C++ Developer
Use the standard library in-contract
Codify existing exposition-only standard library requirements
==categories
contents
==x2032.N4842
50
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
Many of the preconditions and postconditions of the standard library can be
expressed as boolean expressions, and so are encodable using the facilities
that were provided.
==description
In some shape or form, anything documented in the contracts of the standard
library's functions (preconditions, postconditions, other behaviors) is a
candidate for something that should be codifiable as a contract condition.
--

--cppdev.debugger
C++ Developer
Use Debugger
Have runtime able to launch a debugger from an annotation if necessary
==categories
behavior violations
==x2032.N4842
25
==x2032.N4820
40
==x2032.P1429
40
==x2032.P1607
40
==x2032.details
As much as any C++ program is able to do something like signal that a debugger
should be opened, a macro based solution could invoke the platform-specific
functions that would enable that (such as `__debugbreak()` or `raise(SIGTRAP)`).
All of the prior solutions also provided a consistent place to put such a function
call by allowing for setting a custom violation handler, and due to that being
globally consistent we rate them slightly higher.

This is still not a standardized facility, so no solution completely satisfies
this use case within the standard itself.
==description
When handling a contract violation, the ability to trigger a debugger when
possible is currently not standardized but should be available.
--

--cppdev.build.legacy
C++ Developer
Use existing build modes
Have annotations affect executions depending on my existing build modes (eg.
Debug or Release modes in VS)
==categories
control
==x2032.details
Those solutions that would use macros to do global control (N4842 and P1607)
would be able to reference _NDEBUG or similar macros usually associated with
"debug" and "release" builds as input to how they configure contracts.  The
standard, and the build levels specified in N4820 and P1429, are however
completely disconnected from one another.
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
10
==description
Note that "debug" and "release" are not standardized things, but nothing
specified in the standard should preclude those from having some impact on
what behaviors contracts take on in those two modes. It should be possible for
a vendor to map contract modes to their existing native modes.
--

--cdev.contracts
C Developer
Write contracts on my functions
Specify contracts in a way standardizable as part of the C language
==categories
syntax
==x2032.N4842
10
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
None of the contract specifications as a language feature would have been
palatable to the C standards committee, since they all require being able to
attach meaning to an attribute, as well as make use of new identifiers with
special meaning (which are unfriendly to standardize in the macro-heavy C
world.)

A pure C++ macro based contract solution would, however, possibly be
implementable in a fashion that is equally usable from C code.
==description
Important considerations for C are related to any contracts that can go on a
normal C function.  C does have attributes, but it also explicitly calls out
that a conforming implementation can ignore all attributes, as opposed to C++
which has made that a commonly held assumption but has not actually put wording
in the standard to that effect.
--

--cdev.identifiers
C Developer
Write contracts on my functions
Use contracts with macro-safe keywords that are reserved C names (i.e., _Pre,
_Post, _Assert, etc.)
==categories
syntax
==x2032.N4842
10
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
cdev.contracts
==description
Adding new identifiers with meaning in C is generally not acceptable for
standardization, so compatible contracts would either need to use no contracts
or support alternate reserved words for use with contracts.
--

--cdev.violationhandler
C Developer
Write contracts on my functions
Have a common violation handler for both violated C and C++ contracts
==categories
violations
==x2032.N4842
50
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
25
==x2032.details
With no C interoperability easily possible, and the violation handler specified
in terms of an opaque class type (`std::contract_violation`), implementing
that violation handler i C would not have been feasible.

It is, however, likely that any C-based contract solution would be able to
bridge to and from the C++ contract violation handler, since there is no
particularly complex functionality in the violation handler or the violation
object itself.
==description
Importantly, satisfying this requirement would mean making the the argument
to a violation handler meaningful in both C and C++, or requiring platform
vendors to shim between the two (in the case of a C violation handler receiving
a violation from C++ code).
--

--cdev.ignorable
C Developer
Write contracts on my functions
Make all contract semantics optional (so as not to change WG14-N2385 6.7.11 p2)
==categories
behavior
==x2032.N4842
50
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
0
==x2032.details
P1607's explicit semantics require that they behave in a specific way when
asked for.  Similarly, there is an expectation with N4820 and P1429 that build
levels can be set to something other than `off`, but they do allow global control
to do that (so at least one potential program behavior would be buildable
without needing to make contract annotations do anything).

Obviously a macro-based solution would be able to provide this kind of feature.
==description
Assuming contracts continue to be rendered as attributes, C standardization
would require they be semantically optional.

Note that, just as with C++, the ':' in the previous contract syntax does not
match the grammar for attributes in either language, so by a strict reading of
the standards there is no obligation to be ignorable.  ('[[a:b]]' is not a
valid attribute and should be diagnosed as invalid on any current C or C++
compiler).   Many have expressed the view that this opinion is pedantic and
that the spirit of the law is that anything between [[]]s should be ignorable.

Additionally, it is currently a conforming extension to throw away all tokens
between a pair of [[]]s, and there exist numerous compilers that take advantage
of that fact which would be broken by requiring behavior of any constructs that
look like an attribute.
--

--ccppdev.interop
Mixed C/C++ Developer
Maintain mixed code base
Not lose contracts when crossing languages
==categories
general
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
A pure macro-based facility exposes no contracts to callers, regardless of what
language the callers are calling from.  The language-based facilities would not
have readily supported standardizing by WG14.
==description
--

--cdev.cppinterop
Mixed C/C++ Developer
Write contracts on my functions
Expose my contracts to C++ developers through 'extern "C"' declarations of my
functions
==categories
syntax
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
ccppdev.interop
==description
--

--api.communicate.inputsoutputs
API Developer
Communicate my interface to users
Document the expected inputs and expected outputs on my interface
==categories
general
==x2032.N4842
25
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
Precondition and postcondition checks within  a function do something to document
inputs and outputs, as do comments that are readily available without a language
feature.

The language proposals all included the common feature of `[[pre]]` and
`[[post]]` to express this information directly on function declarations, and
have those get checked at runtime.
==description
--

--api.establish.check
API Developer
Establish a contract
Have validation inform me which output values are unexpected or invalid
==categories
general behavior
==x2032.N4842
25
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
api.communicate.inputsoutputs
==description
--

--api.establish.validate_invariants
API Developer
Establish a contract
Have validation inform me which class invariants are violated
==categories
general location
==x2032.N4842
5
==x2032.N4820
5
==x2032.P1429
5
==x2032.P1607
5
==x2032.details
Neither a macro based facility or the language proposals allowed for specifying
at a class level invariants that would be automatically checked (barring
manually adding class invariants as pre and post conditions on every single
function.)
==description
Class invariants have historically been considered of general use, but the
performance impact of checking them can be surprisingly huge.  Previously
these have been left out of proposals for C++ to be added in at a later
date.
--

--api.establish.values
API Developer
Establish a contract
Have validation inform user which input values are unexpected or invalid
==categories
general behavior
==x2032.N4842
25
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
api.communicate.inputsoutputs
==description
This establishes the basic requirement on preconditions in terms of input values.

The more detail available to users about how a contract condition has been
violated the more useful they become.  This means each specific condition
is benefited by being separate (eg. 'x != 0' and 'y != 0' as distinct
conditions instead of requiring that users use 'x != 0 && y != 0').

In addition to that, anything that might be able to capture those values
and expose them to violation handlers for logging would again help benefit
problem diagnosis.
--

--api.establish.preconditions
API Developer
Establish a contract
Have contracts specify their pre-conditions as logical predicates
==categories
location contents
==x2032.N4842
25
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
api.communicate.inputsoutputs
==description
This establishes the basic requirement to use predicates to evaluate input values.
--

--api.establish.invariants
API Developer
Establish a contract
Have contracts specify their class invariants as logical predicates
==categories
location contents
==x2032.N4842
5
==x2032.N4820
5
==x2032.P1429
5
==x2032.P1607
5
==x2032.see
api.establish.validate_invariants
==description
This establishes the basic requirement for invariants in terms of predicates on class members.
--

--api.establish.postconditions
API Developer
Establish a contract
Have contracts specify their post-conditions as logical predicates
==categories
location contents
==x2032.N4842
25
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
api.communicate.inputsoutputs
==description
This establishes the basic requirement to use predicates to evaluate return values.
--

--api.express.values
API Developer
Express predicates
Make reference to either the values of my inputs, or other in-scope identifiers
==categories
contents
==x2032.N4842
75
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
A macro based facility can similarly expose macros to control the enablement of
arbitrary code at arbitrary scopes, and so enables storing values between calling
time and return time manually.

The language-based facilities allow for referencing inputs and outputs, with
the caveat that inputs were only referencable in outputs if they were not
changed.  The language-based facilities explicitly prevented any form of making
additional code execute if contracts were enabled, and thus removed the ability
to store data between the start and end of a function call.
==description
This establishes the basic requirement to reference in-scope variables in order capture values and compute predicates.
--

--api.establish.changedvalues
API Developer
Establish a contract
Make reference to the before and after values of in-out variables (ie. passed
by pointer or reference) in post-conditions
==categories
contents
==x2032.N4842
40
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.express.values
==description
Postconditions often need to state things about how values of output parameters
have changed, or how the values of other global state might have changed
as a result of a function call.  The ability to store copies of state from
before the function call and reference that in a postcondition predicate will
enable a wider variety of conditions to be formulatable.

Ada has this functionality builtin by providing ways to reference explicitly
the original value of a function parameter. C++ makes this more complicated
with the need to consider the handling of move-only or generally non-copyable
types.  More importantly, such copying should absolutely not happen if a
contract is not being evaluated at runtime.
--

--api.establish.changedmembers
API Developer
Establish a contract
Make reference to the before and after values of mutable class members (eg.
<i>new_size = old_size+1</i> after push_back) in post-conditions
==categories
contents
==x2032.N4842
40
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.express.values
==description
Capturing the pre-function state of member variables might also be needed
to state the contracts on many member functions.
--

--api.establish.changedstate
API Developer
Establish a contract
Make reference to the before and after values of global state (eg., <i>global
&gt;= old(global) + 1</i>) in post-conditions
==categories
contents
==x2032.N4842
40
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.express.values
==description
Capturing arbitrary global state for use in a postcondition might prove useful.

This extends to the state of arbitrary other expressions and how that might change
due to the invocation of a function.  Consider this example of what might
be a postcondition of a typical `sleep` function:

```
old(now()) <= now() + sleep_time
```
--

--api.extend.exceptionsafety
API Developer
Extend contractual aspects
Annotate operations as being exception safe
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
No codification of these features is baked into the language itself or added
by the previous proposals.
==description
Exception safety guarantees are often part of the English language contract of
a function, and being able to state that (in a way that tools might be able
to then pick up on and verify) would be useful.
--

--api.extend.threadsafety
API Developer
Extend contractual aspects
Annotate operations as being thread safe
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.extend.exceptionsafety
==description
The proper use of a type in a multithreaded environment can benefit greatly
from being documented in a way that can then be checked and verified.
--

--api.extend.atomicity
API Developer
Extend contractual aspects
Annotate operations as being atomic (ie. all or no changes become visible)
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.extend.exceptionsafety
==description
Establishing more details about what might happen on failure, such as what
external state might be changed in a remote database, is another useful
condition to state.
--

--api.extend.realtime
API Developer
Extend contractual aspects
Annotate operations as real-time (ie. guaranteed to complete within a time
frame)
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.extend.exceptionsafety
==description
--

--api.extend.determinism
API Developer
Extend contractual aspects
Annotate operations as being deterministic (ie. same outputs for same inputs)
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.extend.exceptionsafety
==description
--

--api.extend.purity
API Developer
Extend contractual aspects
Annotate operations as functionally pure (ie. no side effects)
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.extend.exceptionsafety
==description
--

--api.extend.sideeffects
API Developer
Extend contractual aspects
Annotate operations as having global side effects (ie. write to singleton,
file, network, or database)
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.extend.exceptionsafety
==description
--

--api.extend.complexity
API Developer
Extend contractual aspects
Annotate algorithmic complexity
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.extend.exceptionsafety
==description
--

--api.express.runnability
API Developer
Express unrunnable contracts
Be able to use a predicate that is not evaluated at runtime, because it might
be unsafe to run or have stateful side effects
==categories
contents metadata
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
There is no current in-language way to express predicates that will not be
executed at runtime.

N4820 had unchecked contracts leave their evaluation as unspecified, thus making
any predicate that has UB or has side effects potentially evaluated
(specifically, the wording said "it is unspecified if the predicate of an
unchecked contract is evaluated".)

P1429 and P1607's assume semantic, however, attempted to capture the original
intent of the contract proposals and make unchecked contracts not be evaluated,
thus enabling the use of predicates that are not themselves safe to ever
evaluate.
==description
Numerous predicates that might be useful to state also might change the
state of a program in a paradoxical way if checked.  The common example
(originally put forward in P0380) is validating available items on an input
iterator.  Other important examples include checks that might require accessing
special hardware, or doing extensive computations that would invalidate the
results just by taking the time to do them.

These predicates are still useful for those reading the code, still might
benefit from being validated against postconditions of other functions, and
might provide some identifiable code improvements when analyzed by the compiler
without actually executing them at runtime.
--

--api.express.undefined
API Developer
Express unrunnable contracts
Be able to use a predicate that doesn't have a definition, because it hasn't
been written yet, or is infeasible to run
==categories
contents metadata
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
api.express.runnability
==description
Often during development it helps to write contracts first, and that might
even predate having enough of an implementation to fully define the conditions.
Having them in code ensures that the placeholder API to check them is
maintained.  Some functions may never be implementable due to time constraints,
while others will eventually be filled in as time allows.
--

--api.express.uncheckable
API Developer
Express uncheckable contracts
Be able to use a predicate that is not evaluated, because it is simply a
semantic placeholder for a tool
==categories
contents metadata
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
api.express.runnability
==description
Some predicates might even have no meaning within the language itself, but
benefit other tools by being placed into the same contract framework as other
predicates, with meaning to those external tools.
--

--api.express.unimplementable
API Developer
Express uncheckable contracts
Be able to use a predicate that cannot have a complete definition, because it
is inexpressible in the language
==categories
contents metadata
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
api.express.runnability
==description
Many external static analysis tools, and even compilers, can check that
some state is being handled properly which cannot be properly validated within
the language itself.  Consider functions such as "is_deletable" or
"is_reachable".
--

--api.establish.responsibility
API Developer
Establish responsibility boundaries
Inform users which errors are the responsibility of the caller, and which are
the callee
==categories
violations
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
Macros within a function are unable to readily gather information about what
called the function, thus making it infeasible to identify calling code in a
precondition violation in a wholely macro-based facility.

N4820 made it possible to change that for `[[pre]]` annotations on a function
declaration, allowing for the reported source line to be the calling location
if the implementation is willing and able to do so.   There was, however, still
no facility to explicitly point at a caller being the source of a problem
when the problem gets detected within the body of a function (or, for instance,
when delegating to another function without duplicating that function's
preconditions explicitly).
==description
One common realization with having checked contracts in the language is that 
they will then identify bugs that exist in programs.  Identifying the source
of those bugs swiftly is important, and for any contract that is dependent on
a function being called properly that responsibility does not usually lie with
the line of code where the contract is written, but with the place where
the function has been called.
--

--api.resp.preassert
API Developer
Establish responsibility boundaries
Annotate assertions inside function bodies that indirectly test preconditions
(such as malformed data discovered while performing the algorithm) should be
reported to the caller as precondition failures
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.establish.responsibility
==description
Some function preconditions can be expressed as c++ expressions, but are
runtime-expensive.  However, if expressed inside function body as assertions
after some function logic has already been executed,  the check whether the
function has everything that is required is cheap. If I use an assertion like
this,  I want to annotate this assertion as being "precondition-like". The
semantics would be that if it fails,  it is reported as "caller's bug" rather
than callee's bug, and if the build is configured  to runtime-check only
preconditions, such assertion should also be runtime-checked.

As an example, consider a binary search that wishes to check that the input
list is sorted.  There is an expensive check (O(n)) that can be done to verify
that the whole list is sorted on each call, but this would negate the
performance benefits of doing a binary search to begin with.  Another option
is to check just that the elements adjacent to those that are visited are in
properly sorted order.  This will provide some chance of identify unsorted
inputs without making performance unusable, but is also most cleanly done
during the execution of the search algorithm.  Unlike a normal in-body
assertion, a violation identified by this kind of check should be reported to
the caller, as it is a failure on the calling code's part to provide a
properly sorted input list.
--

--api.contract.interface
API Developer
Have contract as part of my interface
Declare contract when I declare the function
==categories
general location
==x2032.N4842
0
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
100
==x2032.details
This is not doable with macros, but was inherent in the proposed contract
solutions.
==description
Putting contracts on the first function declaration makes them easily visible
to anyone looking at a header file for understanding an API.
--

--api.contract.private
API Developer
Keep my user interfaces clean and narrow
Be able to access private implementation details of the class so I don't have
to widen public interface to declare predicates
==categories
contents
==x2032.N4842
100
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
100
==x2032.details
A macro within a function has full access to private data members of that
function's class, as do contracts in all of the language contract proposals.
==description
Often, an interface might be very narrow - consider the interface on an
iterator, which generally just has a few operators and no other functions -
yet there  might be ways to check parts of a narrow contract that depend on
internal state.  Exposing this state so that it can be checked publicly would
require widening the API interface, which is counter to the desire to keep
the use of a type as simple as possible.

On a similar note, sometimes the internal state only approximates the actual
contract, and while better than no checking there is a desire to not expose
that data publicly so that there is no assumption that the data represents
the complete set of requirements on calling code.
--

--api.contract.redeclaration
API Developer
Keep my public interfaces clean and concise
Place function contract conditions on any declaration (e.g., on redeclarations
at the bottom of the header, or on the definition in an implementation file,
where they are less distracting).
==categories
location
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
A macro-based facility obviously has no contracts on any declarations.  The
language based proposals did not allow for contracts on any declaration except
the first one.

Note that [P1320R1](http://wg21.link/P1320R1) was going to be presented in
cologne and sought to alter this state.
==description
Many development methodologies revolve around making readable, well-documented
header files to provide a way to understand API usage. Some contracts might
be simple and readable, but others might involve complex conditions that
distract from readability, and match very simple to read and understand prose
contracts in the documentation.

The benefits (checkability, analysis, etc.) of having the encoded contracts
should not come at the cost of making the primary visible public interface
(the header file) more unreadable.
--

--api.contract.errorhandling
API Developer
Move contract violation out of error handling
Replace uses of error handling to express contract violation (eg.
<i>operator[](size_t n) noexcept [[pre: n &lt; size()]]</i> instead of
throwing)
==categories
general
==x2032.N4842
50
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
This is a design decision when defining an API that could be readily
accomplished with any contract facility.
==description
Historically, rather than providing functions with narrow contracts, software
might have been written to report misuse through exceptions.  Contracts should
provide a better alternative than giving all functions a fully wide contract.
--

--cppapi.invariants
C++ API Developer
Write classes
Declare class invariants that all of my public functions need to maintain
==categories
location
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.establish.validate_invariants
==description
--

--cppapi.class.preconditions
C++ API Developer
Maintain a class hierarchy
Ensure overriding methods have same or wider preconditions (see: Liskov
substitution principle)
==categories
location contents
==x2032.N4842
0
==x2032.N4820
40
==x2032.P1429
40
==x2032.P1607
40
==x2032.details
A wholely macro based facility has no way to automatically integrate with
function overrides.

The language proposals all required that virtual functions have exactly the same
preconditions and postconditions, and so allowed for a subset of what would be
Liskov substitutable.
==description
--

--cppapi.class.postconditions
C++ API Developer
Maintain a class hierarchy
Ensure overriding functions meet their base class postconditions when their
base class preconditions are met (see: Liskov substitution principle)
==categories
location contents
==x2032.N4842
0
==x2032.N4820
40
==x2032.P1429
40
==x2032.P1607
40
==x2032.see
cppapi.class.preconditions
==description
--

--cppapi.class.variability
C++ API Developer
Maintain a class hierarchy.
Allow overriding functions to have narrower preconditions/wider postconditions
if I want to
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
cppapi.class.preconditions
==description
P4810 did not allow any variation in contract conditions through overrides of
a virtual function, though this could be roughly accomplished with assertions
in function bodies instead.

In general, the pre and postconditions of the interface you call through should
be checked to be sure you're meeting the requirements you want to meet.
Similarly, the concrete type's conditions should be checked to be sure it is
behaving properly.  Doing both checks if they are different might be an
acceptable solution to allow flexibility without any increase in risk, at the
possible cost of some performance in checked builds.
--

--api.class.publicinterface
C++ API Developer
Express public class invariants
Express a restriction on the public interface of a type that all callers of the
type can depend upon: can mention only public members, and is checked on entry
and exit from this type's code
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
A macro-based facility is not part of the declared interface to any class,
but only part of the implementation.

The language proposals were limited to functions but not types, and always had
private access.
==description
Requirements on an interface to a function should be impossible when entering
into a type's functions, but there might be a desire to distinguish that
so that checking is done differently when a type calls its own functions.
--

--api.class.publicinvariants
C++ API Developer
Express public class invariants
Check invariants before and after every public method (when called from outside
the type, not when one member function calls another)
==categories
behavior contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.class.publicinterface
==description
General class invariants should be checked for validity before and after any
call to a public member function of a class.  Calls to friend functions need
to be considered as well, as they might benefit from invalidating/validating
invariants.  Similarly, invariants might be checked for all objects of the
type that are being touched whenever a public function is starting or
finishing.
--

--api.class.publiccalls
C++ API Developer
Express public class invariants
Check invariants before and after calling functions that are not part of this
type (including virtual calls)
==categories
behavior
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.class.publicinterface
==description
Calling from a member function to a function of another type (or a possible
subtype) might require verifying that the object's invariants hold prior to
calling the function and that they still hold when the other function returns.
--

--api.class.baseinterface
C++ API Developer
Express base class invariants
Express a restriction on the protected interface of a type that derived types
can depend upon: can mention only protected and public members, and is checked
on entry and exit from this type's code
==categories
location
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.class.publicinterface
==description
Similar to the public API of a class, the protected API is exposed to
subclasses and invariants of that API should be checked whenever the boundary
might be crossed.
--

--api.class.baseinvariants
C++ API Developer
Express base class invariants
Check invariants on entry and exit of every protected method (when called from
the derived type, not when one base member function calls another)
==categories
behavior contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.class.publicinterface
==description
--

--api.class.basecalls
C++ API Developer
Express base class invariants
Check invariants before and after every call to a virtual function (when
calling to the derived type)
==categories
behavior
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.class.publicinterface
==description
--

--api.class.privateinterface
C++ API Developer
Express private class invariants
Express an internal restriction on the private implementation of a type, can
mention any member, and is checked on entry and exit from this type's code
==categories
location
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.class.publicinterface
==description
--

--api.class.privateinvariants
C++ API Developer
Express private class invariants
Check invariants on entry and exit of every public method (when called from
outside the type, not when one member function calls another)
==categories
behavior contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.class.publicinterface
==description
--

--api.class.privatecalls
C++ API Developer
Express private class invariants
Check invariants before and after calling functions that are not part of this
type (including virtual calls)
==categories
behavior
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
api.class.publicinterface
==description
--

--api.class.testing
C++ API Developer
Test my classes
For every member or friend function in my class, run my unit test framework
with checking enabled for every assertion at the point where it is written, and
check every postcondition at every non-exceptional exit, and test my class
invariants on entry and exit from this type's code
==categories
control
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
This level of control is not providable for macros or the language proposals.
==description
--

--cppapi.contracts.async
C++ API Developer
Enforce contracts in async code
Express contracts on callbacks such as std::function, function pointers, or
references to functions, lambdas, or function objects
==categories
location
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
This would require contracts be part of a function type.   Macros are not even
part of a function declaration, let alone its type, and the previous language
proposals did not choose to make contracts part of a function type either.
==description
In general, any callback based solution exposes functions that will be called
that might benefit from having information about their contracts also
transmitted.

This might be implemented by incorporating contracts deeply into the type
system, or in a more limitted way by just facilitating library types like
a function with contracts.
--

--cppapi.contracts.exception
C++ API Developer
Enforce contracts in exception safe code
Express contracts on exceptional exit
==categories
location contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
cppapi.contracts.exception
==description
Generally, postconditions have been assumed to hold when a function returns
normally.  Expressing conditions that will hold if a function returns through
an exception, or both, could also be useful.
--

--cppapi.variadic
C++ API Developer
Use contracts with variadic templates
Allow predicate (fold) expansion
==categories
syntax location
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
cppapi.contracts.exception
==description
Fold expressions using && might be useful for a predicate, but they then lose
any information about which particular argument might have violated the
condition.  Enabling more useful information to narrow that down would be
helpful.
--

--api.coroutines
C++ API Developer
Use coroutines
Define and check pre and post conditions as I would a regular function
==categories
location
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
cppdev.coroutines
==description
Like regular functions, pre and postconditions on coroutines should have
similar semantics.
--

--api.coroutines.invariants
C++ API Developer
Use coroutines
Define and check invariants over all entry and exit points from a coroutine (to
its awaiter or promise)
==categories
behavior
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
cppdev.coroutines
==description
Similar to a class, the state of a coroutine, or what it expects of the state
of the world as it suspends and resumes, might be stated as expected invariants
that could be checked whenever entering and exiting.
--

--int.conform.violation
Integration Developer
Conform to a contract
Be informed any time an interface's contract is violated
==categories
behavior violations
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
This is the purpose of a checked contract facility, though the granularity of
control to limit to or at least include a particular (or all) interface is
not there for all proposals.
==description
--

--int.conform.postconditions
Integration Developer
Conform to a contract
Verify results from a call are expected output values
==categories
behavior
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.see
int.conform.violation
==description
--

--int.build.headeronly
Integration Developer
Build multiple libraries
Use contract-enabled header-only libraries
==categories
general control
==x2032.N4842
50
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
100
==x2032.details
A macro based facility is likely to depend on having a supporting library exist
to make customization and violation handling available.

Nothing about the proposed solutions required this (or, as a language facility,
a library got the supporting functionality needed for free from the compiler's
runtime environment).
==description
--

--int.build.binaries
Integration Developer
Build multiple libraries
Use contract-enabled binary libraries
==categories
control
==x2032.N4842
100
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
100
==x2032.details

==description
--

--int.build.binarycounts
Integration Developer
Build multiple libraries
Only be required to manage a small, common set of build/link configurations
==categories
control
==x2032.N4842
75
==x2032.N4820
40
==x2032.P1429
25
==x2032.P1607
75
==x2032.details
Policies on how many different builds are managed and deployed are entirely
up to users when the facility's controls are all done through macros (either
entirely in N4842 or on top of literal semantics in P1607).

N4820 includes 5 distinct build configurations that might be desired by clients
of a library, and P1429 increases that number to 32, though most are only
interesting in special cases and it is likely that individual vendors would find
a small set that are of actual interest to their clients.
==description
--

--int.build.control
Integration Developer
Debug multiple libraries
Enable checks only within a selected library
==categories
control
==x2032.N4842
50
==x2032.N4820
35
==x2032.P1429
35
==x2032.P1607
50
==x2032.details
The build levels are global, with conditional (and potentially no) support for
using mixed build levels across different libraries.  Macro based solutions are
viable as long as any individual contract always has the same meaning in different
translation units (without ODR violations).
==description
--

--int.build.control2
Integration Developer
Debug multiple libraries
Enable checks on multiple libraries simultaneously
==categories
control
==x2032.N4842
50
==x2032.N4820
35
==x2032.P1429
35
==x2032.P1607
50
==x2032.see
int.build.control
==description
--

--int.debug.callsites
Integration Developer
Debug multiple call sites
Enable checks only on selected call sites
==categories
control
==x2032.N4842
0
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
0
==x2032.details
None of the solutions allowed for a function to be called with different checking
levels without violating the ODR.
==description
Often it is helpful to limit what gets enabled to functions called from
some subset of a program, and the rest of the program might not perform
acceptably enough to test if hose same functions are always checked.
--

--int.violations.information
Integration Developer
Correct failed checks
Be informed what check failed, when, where, and how
==categories
violations behavior
==x2032.N4842
75
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
100
==x2032.details
All of the facilities support checking contracts at runtime and being informed
of details of the violation.   The language proposals included a pluggable
violation handler, although compiler vendors were allowed to not make that
customizable.

A pure macro-based facility suffers from needing to do this for all of the
contract facilities that might be defined and used within a given fully
assembled program.
==description
--

--int.violations.transmit
Integration Developer
Correct failed checks
Transmit check failure information in environment-specific ways (logs, email,
special hardware traps, popup windows, blazing sirens, etc).
==categories
violations
==x2032.N4842
50
==x2032.N4820
90
==x2032.P1429
90
==x2032.P1607
90
==x2032.see
int.violations.information
==description
--

--int.violations.custom
Integration Developer
Correct failed checks
Install custom violation handler where I can inject custom logic to trap errors
==categories
violations
==x2032.N4842
50
==x2032.N4820
90
==x2032.P1429
90
==x2032.P1607
90
==x2032.see
int.violations.information
==description
--

--int.violations.common
Integration Developer
Unify violation handling
Be able to override how library violations are handled in the combined software
to point into my handling code
==categories
violations
==x2032.N4842
50
==x2032.N4820
90
==x2032.P1429
90
==x2032.P1607
90
==x2032.see
int.violations.information
==description
--

--int.violations.override
Integration Developer
Be independent of build environment
Be able to define and override violation handler via source code
==categories
violations
==x2032.N4842
15
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
This might be doable with a fair bit of complexity in a macro-based facility,
and there was no support for this in the language proposals.
==description
--

--int.build.minimize
Integration Developer
Minimize checking overhead
Disable library postconditions, asserts, and invariants, without disabling
library preconditions (assuming the library is tested and stable and my code is
not)
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.details
Different forms of build and runtime control could be built into the macro-based
facilities with varying levels of difficulty.   N4820 and P1429 provided only a
global level of control, limiting greatly the ability to control contract enablement
at finer granularities.   Implementing some of these forms of granularity in
the preprocessor might, however, be very complicated.
==description
--

--int.control.build
Integrated Software Provider
Ensure the combined software is correct
Turn checks on at build time
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.see
int.build.minimize
==description
--

--int.control.runtime
Integrated Software Provider
Ensure the combined software is correct
Turn checks on at run time
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.see
int.build.minimize
==description
--

--int.conrol.subsets.build
Integrated Software Provider
Ensure the combined software is correct
Turn on any subset of individual (call site) checks on at build time
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.see
int.build.minimize
==description
--

--int.control.subsets.runtime
Integrated Software Provider
Ensure the combined software is correct
Turn on any subset of individual (call site) checks on at run time
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.see
int.build.minimize
==description
--

--int.consistency
Integrated Software Provider
Ensure the combined software is correct
Verify all annotations are globally consistent when integrated
==categories
behavior
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
There is no support for this form of checking on a macro-based facility, or from
the language proposals.
==description
--

--int.control.subsets
Integrated Software Provider
Ensure individual features are correct
Have a way to audit (named or semantic) subsets of checks for various
deployments
==categories
control metadata
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.see
int.build.minimize
==description
--

--int.build.common
Integrated Software Provider
Manage binary delivery
Be able to use the same executable regardless of contract enforcement mode
==categories
general control
==x2032.N4842
15
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
A C++20 based facility could determine checking based on runtime configuration
instead of only compile-time configuration.   The language proposals did not
allow for that.
==description
--

--int.testing.control
Integrated Software Provider
Define "Code Under Test"
Selectively enable checking for a set of functions which could name either an
individual function or an overload set
==categories
control
==x2032.N4842
15
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
15
==x2032.see
int.build.minimize
==description
--

--int.testing.controltypes
Integrated Software Provider
Define "Code Under Test"
Selectively enable checking for a set of types and all their members
==categories
control
==x2032.N4842
15
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
15
==x2032.see
int.build.minimize
==description
--

--int.testing.transitivity
Integrated Software Provider
Define "Code Under Test"
Selectively enable checking for a set of types and all their transitively
nested types and members
==categories
control
==x2032.N4842
5
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
5
==x2032.see
int.build.minimize
==description
--

--int.testing.modules
Integrated Software Provider
Define "Code Under Test"
Selectively enable checking for a translation unit or module and all (non
transitive) types and functions within
==categories
control
==x2032.N4842
5
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
5
==x2032.see
int.build.minimize
==description
--

--int.build.unchecked
Integrated Software Provider
Test final deliverable
Turn off build time checking to remove checking overhead
==categories
control
==x2032.N4842
40
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
40
==x2032.details
Macros and the language proposals had minimal concepts of "build time checking",
but they do all enable a global ability to turn off such checking.  That same
global ability can be used to turn off runtime checking.
==description
--

--int.runtime.unchecked
Integrated Software Provider
Test final deliverable
Turn off run time checking to remove checking overhead
==categories
control
==x2032.N4842
50
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.see
int.build.unchecked
==description
--

--int.build.optimize
Integrated Software Provider
Test final deliverable
Turn on run time optimization to leverage annotation assumptions
==categories
behavior control
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
A macro based facility would be able to enable optimizations, but that is likely
going to have limited direct support from most compilers.  (Generally, this would
leverage either `__unreachable()` or `__assume()`.)

N4820 made optimizations enabled for ALL unchecked contracts, while P1429 and P1607
gave mechanisms to opt into that in varying ways.
==description
--

--cpplib.headeronly
C++ Library Developer
Use templates
Be able to ship header only library
==categories
general
==x2032.N4842
50
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
100
==x2032.see
int.build.headeronly
==description
--

--cpplib.insulation
C++ Library Developer
Control the tradeoff between need for client recompilation and contract condition visibility
Insulate contract conditions with the function definition, or insulate only the
definition while putting contract conditions on a redeclaration - visible to
static analysis tools in all TUs.
==categories
location
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
Macro based contract checks will always be in the function body and thus
fully insulated from clients.

The contract annotations of the language proposals could be equivalently put
in function bodies with `[[assert]]` or on the declarations, thus giving some
control over insulation.   The ability to have them visible to clients through
a redeclaration but not visible on the initial declaration was not, however,
in the initial proposals (but was proposed but not seen by EWG in
[P1320R1](http://wg21.link/P1320R1).)
==description
Contract conditions on only the first declaration (as proposed by P4810) mean
that the condition clutters the readable interface and changes in a contract
condition force client recompilation.  Contract conditions not in the header
file are not going to be visible to tools that are attempting to limit what
they consume to a single translation unit.  Combined, these result in a desire
to sometimes put the contracts with the implementing definition (in a .cpp
file) and sometimes put them in a redeclaration in a header file (where one
might also put inline function definitions).

For free functions this would just require relaxing the requirements on where
contracts are.  For member functions, allowing member function redeclaration
would be needed to put the contracts in a less obtrusive place that is still
visible outside of the defining TU.  See P1320 for more discussion of this.
--

--lib.maintenance.noconfig
Library Provider
Simplify maintenance
Not require extra build steps to be documented
==categories
control
==x2032.N4842
25
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
25
==x2032.details
Any contract facility that allows control without source code manipulation will
require some build time control, either through compiler flags or macros, though
all should have been usable with some default behavior if no explicit choices
were made at build time.
==description
--

--lib.maintenance.nowhining
Library Provider
Simplify maintenance
Not have users complain about my product due to modifications of annotations
resulting from their build configuration
==categories
control
==x2032.N4842
75
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
75
==x2032.details
A macro based facility could provide concrete semantics similar to P1607, thus
making contracts that cannot have their behavior changed from the command line.

N4820 and P1429 contracts are always subject to build modes, leaving no way to
enforce that a particular behavior is applied to a given contract annotation.
==description
--

--lib.integration.noconfig
Library Provider
Support successful integration
Not require extra build steps to be learned or performed
==categories
control
==x2032.N4842
25
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
25
==x2032.see
lib.maintenance.noconfig
==description
--

--lib.integration.nowhining
Library Provider
Support successful integration
Not have my users accidentally modify my careful annotations
==categories
control
==x2032.N4842
75
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
75
==x2032.see
lib.maintenance.nowhining
==description
--

--arch.nomacros
Technical Architect
Maintain quality of code base
Express assertions in a way that does not rely on C macros (i.e., there is no
valid technical reason for a programmer not to use the new way, including
space, time, tooling, and usability/complexity reasons, compared to C's assert
macro)
==categories
syntax
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
Contract checks without a language facility are not feasibly doable without macros.

All of the language proposals require macros in some form or other to satisfy
many of the use cases in this document, but still provide a basic contract
checking facility with no macros used at all.
==description
--

--arch.complete
Technical Architect
Have a consistent and holistic contracts facility
Specify preconditions/postconditions/assertions/invariants that express my
expectations about the expected valid state of my program in the form of
compilable boolean expressions, that can be checked statically or dynamically
(as opposed to disjointed state where these features are factored into bits)
==categories
general
==x2032.N4842
0
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
Obviously the language does not have this now, and the language proposals all
attempted to provide this.
==description
--

--hardware.performance
Hardware Architect
Improve system-level performance
Be able to design new hardware + optimizations, carefully dovetailed into one
another, that depend on statically-unprovable facts being annotated in the code
==categories
general behavior
==x2032.N4842
0
==x2032.N4820
25
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
N4820's inability to have contracts that are never executed prevents this from
being leveraged for many novel features.  P1429 and P1607's assume semantic
fixed this.
==description
--

--sdev.bestpractices
Senior Developer
Set an example
Demonstrate best practice in defensive programming
==categories
general
==x2032.N4842
50
==x2032.N4820
25
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
Any basic contract checking facility can be used to implement defensive
programming.

N4820's implicit assumption of any unchecked contract, however, is unlikely to
ever be viewable as a best practice to use by anyone.
==description
--

--sdev.quality
Senior Developer
Enforce code quality
Discourage reliance on observable out-of-contract behavior by causing check
failure to hard stop program or build
==categories
general
==x2032.N4842
50
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
This behavior is available in any of the facilities, though not as strongly
enforced when a user has control over the violation handler.
==description
--

--sdev.maturity
Senior Developer
Enforce mature, finalized contracts
Disable continuation on violation of stable and correct individual contracts
==categories
control
==x2032.N4842
50
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
75
==x2032.details
The global controls of N4820 and P1429 do not allow for control over an individual
contract's behavior (continuing or not, checked or not) based on the maturity of that
specific contract.
==description
--

--sdev.control
Senior Developer
Enforce mature, finalized contracts
Disable remapping of semantics on stable and correct individual contracts
==categories
control
==x2032.N4842
50
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
75
==x2032.see
sdev.maturity
==description
--

--jdev.understand.contracts
Junior Developer
Understand the API
A uniform, fluent description of expected input values, expected output values,
side effects, and all logical pre and post conditions
==categories
general
==x2032.N4842
0
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
Without a language feature contract descriptions are library-specific and not
uniform.  With it, the only non-uniformity comes in when libraries build
extra infrastructure on top of the language-provided facility.

A library and a language-based facility will, however, be able to provide
a user understandable details of why a contract violation might have made a
program abort or fail to compile.
==description
--

--jdev.understand.violations
Junior Developer
Understand the API
Be informed when my usage is out of contract
==categories
violations
==x2032.N4842
50
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
jdev.understand.contracts
==description
--

--jdev.understand.buildfailures
Junior Developer
Understand the program
Know why my software is not building
==categories
behavior
==x2032.N4842
50
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
jdev.understand.contracts
==description
--

--jdev.understand.aborting
Junior Developer
Understand the program
Know why my software is aborting
==categories
behavior
==x2032.N4842
50
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
jdev.understand.contracts
==description
--

--jdev.understand.omniscience
Junior Developer
Understand the program
Know why my software is out of contract
==categories
behavior
==x2032.N4842
50
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
jdev.understand.contracts
==description
--

--jdev.understand.buildviolation
Junior Developer
Understand the program
Know that my program or build was halted due to contract violation
==categories
behavior
==x2032.N4842
50
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
jdev.understand.contracts
==description
--

--jdev.understand.all
Junior Developer
Understand the facility
Be able to build a program with contracts after reasonably short tutorial
==categories
general
==x2032.N4842
50
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
Whether with a library or any of the proposed language features, simple contract
use remains simple.
==description
--

--jdev.understand.keywords
Junior Developer
Understand the facility
Have keywords with precise and unambiguous meanings
==categories
syntax
==x2032.N4842
0
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
75
==x2032.details
Without a language feature there are no new keywords.  N4820 and P1429 include
`axiom` which has shown to have significant disagreement over what meaning it
has in the context of contracts (see [P1672](http://wg21.link/P1672R0)).

The keywords provided by P1607 are all very precisely defined.
==description
--

--jdev.bestpractices
Junior Developer
Improve my code
Learn about software best practices by example
==categories
general
==x2032.N4842
50
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
jdev.understand.contracts
==description
--

--adev.fast
Agile Developer
Iterate quickly
Be able to write and modify contracts quickly without heavy boiler plate or up
front cost
==categories
general
==x2032.N4842
0
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
The general use of contracts once they are a language feature is quick to get
started on.   Without a language feature, getting started requires acquiring or
implementing a library to provide the feature.
==description
--

--adev.evolve
Agile Developer
Safeguard evolving code
Assert against conditions I am aware of but not finished handling fully
==categories
behavior
==x2032.N4842
20
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
75
==x2032.details
Without a language-based facility the only way to enter a not-yet-implemented
contract is as a comment, which is of limited utility.

P1607's ignore and assume semantics both allow for referencing undefined functions,
and thus enable writing a planned contract while preserving writing the
implementation of that check for a future sprint.   N4820 provides no way
to get that semantic for a contract annotation, and while P1429's assume semantic
would, there is no way in code to write such a contract.
==description
--

--bdev.confidentiality
Business Developer
Maintain confidentiality
Not expose diagnostic information (source location, expressions, etc.) in the
software I deliver to clients, even when I choose to have contracts enforced in
the software I deliver
==categories
violations
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
A macro-based library could choose to forgo including this information, or
provide flags to control that.

None of the language features proposed include that ability.
==description
--

--pdev.speed
Performance Sensitive Developer
Enable better performance
Annotate my code with assumptions, likelihoods, or reachability information
that a tool might not be able to deduce, but that I would be confident of
==categories
behavior
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
int.build.optimize
==description
--

--pdev.morespeed
Performance Sensitive Developer
Enable better performance
Be able to give statically-unprovable facts to current and novel optimizers in
terms of semantics my program does not depend-on but optimizers can't figure
out
==categories
behavior
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
int.build.optimize
==description
--

--pdev.footgun
Performance Sensitive Developer
Enable better performance
Accept responsibility for a malformed program that might result from eventually
false information given by my annotations
==categories
behavior
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
int.build.optimize
==description
--

--pdev.safety.isolation
Performance Sensitive Developer
Have safety critical paths
Isolate safety checks from performance annotations
==categories
control metadata
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
A macro-based library could provide this distinction.  None of the language
proposals include this, and importantly all of them allow for a contract to
be assumed and thus subvert any future "safety checks" that attempt to handle
out-of-contract behavior more elegantly.
==description
--

--pdev.safety.critical
Performance Sensitive Developer
Have safety critical paths
Retain checking even when optimizing with performance annotations
==categories
control metadata
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
15
==x2032.P1607
20
==x2032.details
N4820 provides no way to turn checking off locally without bringing in assumption.
P1429 at least provides a way to build an application without assumption of checks,
and macro-based solutions on top of P1607 or a fully-macro based solution would be
able to allow for this kind of distinction with some effort.
==description
--

--qdev.checkall
Quality Sensitive Developer
Enable full checking
Ensure all checks (pre, post, assert, invariant) are enabled
==categories
control
==x2032.N4842
25
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
75
==x2032.details
A disparate set of macro-based libraries makes it hard to turn on all checking.

N4820 and P1429 allow for this to be done very easily with build modes.  P1607
allows for code to subvert this kind of control by providing explicit semantics
for a particular contract that cannot be externally altered.
==description
--

--qdev.correctness
Quality Sensitive Developer
Validate correctness
Signify the predicates that should be verified by an analysis tool
==categories
control
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
25
==x2032.details
It can be argued that the primary intention of `axiom` was to only provide information
to static analysis tools, so both of the proposals that include that have that here, even though
the wording itself added in undefined behavior to that level, and made no mention of this purpose.

A macro-based facility could integrate with a static analysis tool for this purpose,
but would require tools to choose to support it.
==description
--

--qdev.tooling
Quality Sensitive Developer
Manage multiple tools
Signify subset of individual annotations to be consumed by a specific kind of
verification tool
==categories
metadata
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
25
==x2032.see
qdev.correctness
==description
--

--qdev.tooling.control
Quality Sensitive Developer
Manage multiple tools
Signify subset of individual annotations to be consumed by a specific instance
of verification tool
==categories
metadata control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.see
qdev.correctness
==description
--

--qdev.tooling.undefined
Quality Sensitive Developer
Manage multiple tools
Use predicates that may not be understood by all instances of verification
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
25
==x2032.P1607
25
==x2032.details
Only P1429 and P1607 allow predicates to remain undefined if not referenced
and not checked at runtime.
==description
--

--qdev.tooling.undefinedkinds
Quality Sensitive Developer
Manage multiple tools
Use predicates that may not be understood by all kinds of verification
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
25
==x2032.P1607
25
==x2032.see
qdev.tooling.undefined
==description
--

--qdev.tooling.behavior
Quality Sensitive Developer
Manage multiple tools
Integrate the results of that static checker into how my program behaves in
different ways: assume proven predicates, make unprovable predicates ill-
formed, etc.
==categories
behavior
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.details
P1607 or a wholely macro-based facility provide the only direct way to integrate
the results of analysis into specific behaviors for contract checks.
==description
--

--qdev.testing
Quality Sensitive Developer
Unit test predicates
Override failure handler to trigger test failure instead of termination
==categories
control violations
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
All of the proposals included a conditionally supported custom violation handler
which could be used to test that checks are actually checked at runtime in a unit
test (at least, for noexcept functions).   A macro-based facility can accomplish
this as well (and this is the foundation of all negative testing in BDE, see
[bsls_asserttest.h](https://bbgithub.dev.bloomberg.com/bde/bde/blob/master/groups/bsl/bsls/bsls_asserttest.h)
for an example of how that might be implemented).

Importantly, the lack of by-default runtime changing of violation handler behavior
means that a custom violation handler must be written to get the full functionality
needed - when testing that a check is violated, you want the violation handler to
throw so you can recover to do more tests, while when testing anything else you
want a hard error because a bug has been found by your testing.
==description
--

--qdev.handler.testing
Quality Sensitive Developer
Unit test violation handlers
Have a way to run handler on all combinations of available build modes
==categories
violations
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
The proposal in N4820 and all of its descendants prohibited any way to
directly invoke the violation handler.  A macro-based facility can expose this
with relative ease (and, for example, BDE does with the macro `BSLS_ASSERT_INVOKE`).
==description
--

--qdev.fuzz.testing
Quality Sensitive Developer
Catch unexpected failure modes
Log all predicate failure during fuzz testing
==categories
control behavior
==x2032.N4842
25
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
75
==x2032.see
qdev.checkall
==description
--

--crit.control
Critical Software Developer
Have a verifiable release system
Be able to control the configuration of contracts from a central point
==categories
general control
==x2032.N4842
25
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
50
==x2032.details
A macro based facility, or macros built on top of P1607, could provide this -
with the major limitation that there might be multiple such facilities to
configure within a single application.

N4820 and P1429 only provide global controls over how contracts behave.
==description
--

--crit.noundef
Critical Software Developer
Avoid undefined behavior
Have contract violation at run-time always have well-defined behavior
==categories
behavior control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
75
==x2032.P1607
50
==x2032.details
Only P1429 allows removing any use of an `assume`-like semantic from contracts.
A macro-based facility can choose to provide that (using various forms of
non-portable or semi-portable implementations).   N4820 provides no way to
turn off contract checks without them introducing undefined behavior.

P1607 Allows for this, but also allows for the explicit use of the `assume`
semantic when desired, which does not allow for altering how it behaves.
==description
--

--crit.recovery
Critical Software Developer
Not have a faulty program lead to catastrophic failure
Have access to a recovery path after contract violation
==categories
behavior
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
75
==x2032.P1607
50
==x2032.details
With the right build or diligently avoiding the use of the `assume` semantic
recovery paths work properly after violations, although the check itself would
need to be duplicated.
==description
--

--crit.redundancy
Critical Software Developer
Not have a faulty program lead to catastrophic failure
Be able to express error handling that may be redundant with contract checking
==categories
behavior
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
75
==x2032.P1607
50
==x2032.see
crit.recovery
==description
--

--crit.interaction
Critical Software Developer
Not have a faulty program lead to catastrophic failure
Not have contract build or run modes possibly be able to change or disable
related error handling in any way
==categories
behavior
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
75
==x2032.P1607
50
==x2032.see
crit.recovery
==description
--

--crit.locality
Critical Software Developer
Be assured a critical violation uses a critical recovery path
Couple recovery path to a specific contract within the source
==categories
contents behavior
==x2032.N4842
25
==x2032.N4820
10
==x2032.P1429
10
==x2032.P1607
10
==x2032.details
The only viable option with the language proposals would be a custom violation
handler that access a diligently updated thread-local recovery path when there
is a violation.  There is no innate support for this built into the facilities.
==description
--

--crit.testing
Critical Software Developer
Meet code coverage requirements
Be able to run both success and failure branches in my test environment
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
75
==x2032.P1607
50
==x2032.see
crit.recovery
==description
--

--crit.production.checking
Critical Software Developer
Have redundant layering
Be able to continue to run checks in a production environment (even after
formal testing is complete)
==categories
control
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
P1429 gives complete flexibility about what levels are checked or not in the
builds you choose to deploy to production.  P1607 and a macro-based facility
allow building that same kind of functionality.
==description
--

--crit.more.coverage
Critical Software Developer
Maximize coverage
Be able to run checks in a production environment that are considered "cheap"
compared to the expected cost of entering an invalid state
==categories
control
==x2032.N4842
25
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
50
==x2032.details
N4820 and P1429 both explicitly consider cost as the primary metadata that can
be put on a contract annotation (via a level of `default` or `audit`).  This
doesn't allow for any more granularity in that expression of cost, but it is
==description
--

--crit.noassume
Critical Software Developer
Avoid unexpected or undefined behavior
Ensure checks will never be __assume'd/__builtin_assume'd by the compiler as if
they were facts injected into the program (otherwise, if such an assumption
ever failed, I would be running a different program that is not equivalent to
the one I wrote; assumptions can expand the set of possible executions by
injecting facts not otherwise knowable to the compiler)
==categories
control
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
50
==x2032.P1607
0
==x2032.details
Only P1429 provides the a way to configure contract annotations to never
be assumed.
==description
--

--sec.noattacks
Security Sensitive Developer
Limit attack vectors
Be unable to insert code paths (eg. violation handlers) at run time (eg. build
time only)
==categories
behavior violations
==x2032.N4842
0
==x2032.N4820
90
==x2032.P1429
90
==x2032.P1607
90
==x2032.details
None of the contract facilities allow any runtime alteration of the violation
handler.

Note importantly that an application may choose to install a custom violation
handler that delegates to something that is runtime controllable, so this
restriction is circumventable if the compiler allows for setting a custom
violation handler.
==description
--

--sec.certify
Security Sensitive Developer
Deliver a certified product
Have build tool only link to a preapproved violation handler
==categories
violations
==x2032.N4842
0
==x2032.N4820
90
==x2032.P1429
90
==x2032.P1607
90
==x2032.details
The wording for N4820 and its derivatives allows for a compiler to choose to not
allow for changing the violation handler to something user defined.
==description
--

--analysis.runtime
User of Analysis Tools
Improve runtime correctness
Have runtime checks generated by the tool
==categories
behavior
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
50
==x2032.details
None of the proposals or the language itself support direct integration with a
static analysis tool.   Explicit literal semantics, however, could be injected
into code by such a tool to generate computed contract behavior - runtime checking,
optimizations, or otherwise.
==description
--

--analysis.optimization
User of Analysis Tools
Improve runtime performance
Have runtime optimizations generated by the tool
==categories
behavior
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
50
==x2032.see
analysis.runtime
==description
--

--analysis.symbolic
User of Analysis Tools
Allow symbolic analysis
Have symbolic proofs for soundness and consistency performed before compile
time
==categories
behavior
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
Proofs of soundness are certainly aided by stating contract annotations and
asking for validation of those annotations.   Tooling will need to catch up
to leverage this and do such proving.

Many such proofs rely on being able to state additional facts that are not easy
to codify as boolean checks, and those are often needed to thoroughly prove
even much simpler predicates, so none of the proposed solutions are complete
for this purpose.
==description
--

--analysis.compiletime
User of Analysis Tools
Allow code analysis
Have code source, AST, or instruction inspection during compile time
==categories
behavior
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
75
==x2032.P1607
75
==x2032.see
analysis.symbolic
==description
--

--analysis.binaries
User of Analysis Tools
Allow binary analysis
Have binary inspection after compile time
==categories
behavior
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
In principle contract checks could be carried forwarded and recorded in binaries
to allow for post-compile verification.  It seems unlikely that a non-builtin
facility would be standardized in binary files in such a way.
==description
--

--analysis.information
User of Analysis Tools
Improve the quality of analysis
Be able to hint to the analyzer information it may be unable to deduce from
source code alone (eg. <i>5 / opaque(); [[ opaque() != 0]]</i>)
==categories
contents
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
75
==x2032.details
None of the proposals allow for hints that are exclusively for the static
analyzer to use, but the P1607 `ignore` semantic could be used for such a
purpose.
==description
--

--analysis.legacy
Provider of Analysis Tools
Extend my existing engine
Be able to map pre-existing contract features in tools to a standardized
language syntax
==categories
general
==x2032.N4842
0
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
75
==x2032.details
Only a very limited legacy framework (such as the C `assert` macro)
that completely falls within the functionality
provided by N4820 would be migratable without drastic changes in behavior.

P1607 sought to provide more flexibility for reimplementing most legacy frameworks
in terms of common semantics provided by the language.
==description
--

--teach.bestpractices
Teacher
Demonstrate best practice
Be able to express defensive programming, programming by contract, and test
driven development to introductory students
==categories
general
==x2032.N4842
25
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
100
==x2032.details
Basic defensive programming is directly expressable through any of the proposed
contract facilities.   Without a language feature, custom libraries must be used
and that is not portable.

Advanced features of contract lifecycle are more difficult to teach when not
directly supported, and none of the proposals provide a complete solution for
that behavior (see [P1332](http://wg21.link/P1332R0) for a broad discussion of
what sorts of lifecycle considerations impact contract use), while only
P1607 provides a way to do so at all at a non-global granularity.
==description
--

--teach.standardized
Teacher
Demonstrate best practice
Not rely on custom libraries or proprietary extensions
==categories
general
==x2032.N4842
0
==x2032.N4820
100
==x2032.P1429
100
==x2032.P1607
100
==x2032.see
teach.bestpractices
==description
--

--teach.lifecycle
Teacher
Demonstrate best practice
Demonstrate mock lifecycle by switching simple compiler flags to control which
checks are enabled
==categories
general control
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
75
==x2032.see
teach.bestpractices
==description
--

--teach.portable
Teacher
Manage many students
Have examples compilable by a standard compiler on any system
==categories
general
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
75
==x2032.see
teach.bestpractices
==description
--

--teach.dumbstudents
Teacher
Manage many students
Have examples that are easy to build without digression into build systems
==categories
general
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
40
==x2032.P1607
40
==x2032.details
More advanced usages with P1429 or P1607 are clearly dependent on more
complicated configuration.   N4820 provides a simple set of flags (build modes) that would
arguably be easiest to teach and use.

Note that nothing in P1429 prevented the support for the same set of build
modes in addition to the more specific semantic per level setting that it
required.
==description
--

--teach.teachable
Teacher
Build layers of understanding
Have simple explanation of assertions and their use to support simple
programming tasks, including debugging erroneous programs.
==categories
general
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
75
==x2032.details
N4820 and P1429 provide the least advanced features, but all of the proposals
allow for basic contract use to be done (`default` level contract annotations)
without any knowledge of the more advanced options that might be available.
==description
--

--teach.layering
Teacher
Build layers of understanding
Support the ability for advanced uses of contracts to be distributed across
many different courses in a C++-focused computer science curriculum.
==categories
general
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
75
==x2032.see
teach.teachable
==description
--

--compiler.benice
Compiler Developer
Deliver best experience to my customers
Maximize implementation freedom by limiting what is strictly required by the
standard
==categories
general
==x2032.N4842
0
==x2032.N4820
40
==x2032.P1429
40
==x2032.P1607
75
==x2032.details
The explicit specification of build modes seems to be seen as highly restrictive
by compiler vendors, and the less specific the standard is about that
aspect of the facility the more this user base seems to be satisfied.
==description
--

--compiler.best
Compiler Developer
Deliver the best implementation
Have a clear and simple specification that meets clear need
==categories
general
==x2032.N4842
0
==x2032.N4820
15
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
N4820 had many open questions about its specification where it had diverged
from the original contract proposals.  The semantic presentation in P1429 and
P1607  sought to be very precise about what was expected of program behavior
for any given contract.
==description
--

--large.complex
Large Codebase Developer
Debug complex issues
Have composable and fine grained control over which checks are run, without
requiring source code changes. Specifically the checks for only one function or
some grouping of functions
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.details
A macro based facility could build this form of subsetting with a great deal of
effort, though callsite based checking does not seem feasible in any macro based
facility.  N4820 and P1429 provide no fine grained control of checks.
==description
--

--large.critical
Large Codebase Developer
Enable/Disable checking on critical/hot paths
Control whether checks are run based on where they are being called from
==categories
control
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
large.complex
==description
--

--large.modernize
Large Codebase Owner
Modernize my code base
Introduce standardized contracts to replace my macro-based contracts
==categories
control behavior
==x2032.N4842
0
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
75
==x2032.see
analysis.legacy
==description
--

--large.stillmacros
Large Codebase Owner
Modernize my code base
Have my existing macro-based facilities interoperate smoothly with standardized
contracts so I can do the migration gradually
==categories
syntax control
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
75
==x2032.details
Only by mapping to literal semantics could a more advanced contract facility be
able to maintain behaviors while still using the same underlying facility that
the language provides.
==description
--

--large.observation
Large Codebase Owner
Introduce new contracts into an existing system
Have failed individual checks from existing code optionally warn instead of
hard stop
==categories
behavior
==x2032.N4842
25
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
75
==x2032.details
N4820 and P1429 provide a continuation mode to be able to make this decision
at a global (or translation unit) scope.  P1607 provides the ability to do
this per-contract.
==description
--

--large.introduction
Large Codebase Owner
Introduce new contracts into an existing system
Have failed checks from a new library optionally warn instead of hard stop
==categories
behavior
==x2032.N4842
25
==x2032.N4820
25
==x2032.P1429
50
==x2032.P1607
75
==x2032.see
large.observation
==description
--

--large.separability
Large Codebase Owner
Introduce new parameters or invariants into a contracts based system
Be able to include distinct clauses for each parameter or invariant with their
own individual failure or build controls
==categories
location control
==x2032.N4842
25
==x2032.N4820
75
==x2032.P1429
75
==x2032.P1607
75
==x2032.details
All of the language proposals allowed for multiple distinct annotations on a
single function.
==description
--

--large.newenvironment
Large Codebase Owner
Introduce new elements into a contracts based system
Have failed checks caused by a change in environment optionally warn instead of
hard stop
==categories
control behavior
==x2032.N4842
25
==x2032.N4820
25
==x2032.P1429
50
==x2032.P1607
75
==x2032.see
large.observation
==description
--

--large.newcompiler
Large Codebase Owner
Introduce new elements into a contracts based system
Have failed checks caused by a change in compiler optionally warn instead of
hard stop
==categories
control behavior
==x2032.N4842
25
==x2032.N4820
25
==x2032.P1429
50
==x2032.P1607
75
==x2032.see
large.observation
==description
--

--large.nogoingback
Large Codebase Owner
Prevent regressions
Have trusted contracts fail fast and hard stop
==categories
control behavior metadata
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
10
==x2032.P1607
75
==x2032.details
The global controls of N4820 and P1429 limit the ability to enforce only those
checks that are trusted, and provide no natural way to mix some continuing contracts with
some non-continuing contracts.  (P1429 would allow this by assigning different
semantics to `audit` and `default` level contracts, but that would conflict with the
intended distinction between those levels based on cost of checking.)
==description
--

--large.scalability
Large Codebase Owner
Scale violation handling
Be able to log violations in my organization specific format
==categories
violations
==x2032.N4842
25
==x2032.N4820
90
==x2032.P1429
90
==x2032.P1607
90
==x2032.details
All of the proposals with a global pluggable violation handler allow this
form of customization, though it is not required by any that a compiler actually
allow the customization of the violation handler.
==description
--

--large.simulation.disable
Large Codebase Owner
Allow simulation or post-mortem testing of known failure modes
Optionally disable checking on a subset of individual annotations
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.details
Subsets of annotations can be called out with macro-based solutions, but not with the
global controls of N4820 or P1429.
==description
--

--large.simulation.enable
Large Codebase Owner
Allow simulation or post-mortem testing of known failure modes
Optionally allow checking of a subset of individual annotations to fail and
access its recovery path
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.see
large.simulation.disable
==description
--

--large.simulation.ignore
Large Codebase Owner
Allow simulation or post-mortem testing of known failure modes
Optionally allow checking of a subset of individual annotations to fail and
continue failing
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
25
==x2032.see
large.simulation.disable
==description
--

--large.perfcontrol.build
Large Codebase Owner
Manage performance cost
Constrain the set of built time checks according to their performance overhead
==categories
control
==x2032.N4842
0
==x2032.N4820
25
==x2032.P1429
25
==x2032.P1607
20
==x2032.details
The language proposals had minimal control over build-time checking, but were
focused on doing any constraining based on the cost of the check.
==description
--

--large.perfcontrol.runtime
Large Codebase Owner
Manage performance cost
Constrain the set of runtime checks according to their performance overhead
==categories
control
==x2032.N4842
0
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
40
==x2032.see
large.perfcontrol.build
==description
--

--large.narrowing
Large Codebase Owner
Tune contract width in complex system
Be able to narrow individual contract so it fails in testing not in production
==categories
control behavior
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
50
==x2032.details
A P1607 contract can have a macro to control individual semantics and go through
a lifecycle where it is checked or enforced in testing but left ignored in production.
Without global control, this cannot be done with N4820 or P1429.
==description
--

--embedded.nochecking
Small Machine Developer
Minimize executable footprint
Remove all checking and diagnostic (eg. source location) overhead entirely from
the final binary
==categories
control
==x2032.N4842
25
==x2032.N4820
50
==x2032.P1429
50
==x2032.P1607
50
==x2032.details
The language based proposals allow for the removal of checking without
==description
--

--embedded.nologging
Small Machine Developer
Minimize executable footprint
Remove all logging and diagnostic (but not checking) overhead from the final
binary
==categories
control violations
==x2032.N4842
25
==x2032.N4820
10
==x2032.P1429
10
==x2032.P1607
10
==x2032.details
None of the proposals allow for total removal of logging information from
the generated code, while a macro based facility could support that option.

It would conceivable be possible for link time optimization to recognize that
a violation handler made no use of source information/did no logging and then
it would be able to remove that source information as well, but this would have
significant compile time overhead on a system.
==description
--

--embedded.minimize
Small Machine Developer
Minimize executable footprint
Remove all but the most important diagnostic overhead from the final binary
==categories
control
==x2032.N4842
25
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
embedded.nologging
==description
--

--wg21.everythingelse
Language Developer
Interoperate with Contracts
Have a clear way to understand how contracts will interact with the standard
library
==categories
general behavior
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.details
None of the proposed solutions began integration with the rest of the standard,
though they would have facilitated it in various ways.
==description
--

--wg21.otherfeatures
Language Developer
Extend contracts beyond pre/post conditions on functions
Be able to use contract-like syntax on past or present runtime checkable
language features such as switches, pattern matching, etc. or what might happen
on signed integer overflow, etc. This might allow configuration of trapping,
logging, or assuming in other areas of language UB.
==categories
location
==x2032.N4842
0
==x2032.N4820
0
==x2032.P1429
0
==x2032.P1607
0
==x2032.see
wg21.everythingelse
==description
--

